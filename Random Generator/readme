Những thứ hiểu được thông qua project:
-	Biến dev_t được dùng để lưu trữ major và minor number (số hiệu file thiết bị).
-	Kernel ring buffer có tính chất line buffered, vì vậy hàm printk() – hàm in ra kernel log – cần phải luôn được kết thúc với \n.
-	Không tương tác trực tiếp với buffer *buf được nhắc đến trong các operation như read hay write, vì có thể gây ra undefined behavior. Thay vào đó, sử dụng các hàm như copy_to_user() (hoặc put_user()), và copy_from_user() (hoặc get_user()).
-	Không nên dùng while(1), while(true), hoặc tương tự trong kernel. Dù gọi ở system call hoặc init() cũng đều không trả về kết quả tốt. Và thông thường những process này không có cách để kết thúc. Thay vào đó, sử dụng timer.
-	Convert từ type int thành char bằng cách + ‘0’.
-	copy_to_user() và copy_from_user() đều không thể sử dụng với type int, vì vậy cần phải chuyển từ type int sang type char.
-	I/O redirection > < có độ ưu tiên cao hơn cat command.
-	Trong project 02, thực chất hàm write có thể được loại bỏ bằng cách xoá hàm và pointer trỏ tới nó trong file operations. Tuy vậy, để demonstrate operation write bằng echo, cũng như write là một trong những operation cơ bản nên nhóm em vẫn giữ lại.
-	alloc_chrdev_region() và register_chrdev_region() đều có thể được sử dụng. Tuy nhiên, hàm register_chrdev_region() cung cấp số hiệu file thiết bị (major/minor number) mong muốn cho kernel thông qua parameter đầu tiên, và dựa vào tình trạng (available hoặc không) mà kernel sẽ cấp phát số hiệu đó cho thiết bị. Còn hàm alloc_chrdev_region() có tính “động” (dynamic) hơn khi tìm ra một giá trị làm device number dựa vào starting minor number (parameter thứ 2), và biến count (parameter thứ 3),  sau đó lưu nó vào parameter truyền vào đầu tiên (đó là lí do khi dùng hàm alloc_chrdev_region() thì parameter đầu tiên cần phải được truyền tham chiếu (pass by reference) với dấu &.
Hàm này thường được gọi trong hàm khởi tạo của character driver.
-	cdev_init() và cdev_add() đều thực hiện phần việc đăng kí character device. Nói ngắn gọn, để sử dụng một character driver thì cần phải register nó với hệ thống, sau đó expose nó với user space. Và hàm cdev_add() cùng với cdev_init() sẽ có việc add character device vào hệ thống, nếu hàm được thực hiện thành công, thì thiết bị coi như đã có thể hoạt động và user có thể gọi những operation của nó thông qua kernel. Từ lúc đó, thiết bị mới được register sẽ được hiển thị trong /sys.
Và phần việc còn lại sẽ được thực hiện bởi device_create(), đó là cấp quyền truy cập từ user space (khác với kernel space được nêu ở trên). Để làm việc này thì yêu cầu phải có device node trong /dev. 
Trước khi gọi hàm device_create(), cần phải gọi hàm class_create() để tạo ra một lớp thiết bị ảo, rồi gọi chính hàm device_create() với parameter bắt buộc phải là class được tạo ra với hàm class_create() được nêu trên. Hàm device_create() cuối cùng sẽ tạo ra một file thiết bị trong /dev.
-	Ngay khi uninstall, c_dev sẽ được xoá bỏ, device trong /dev cũng sẽ được loại bỏ thông qua hàm device_destroy() (gắn cùng với số hiệu file thiết bị). Lớp thiết bị ảo được tạo với hàm class_create() cũng sẽ được huỷ thông qua class_destroy() và sau đó device number cũng sẽ được unregister thông qua hàm unregister_chrdev_region() (hàm thường thấy khi không thể class_create(), device_create(), hay cdev_add()).
-	Ngoài ra sau khi xem video hướng dẫn của các thầy, khi phải dùng chmod để cấp quyền đọc bằng tay cho hàm cat tới /dev/<…> mà không thể dùng sudo cat /dev/<…>, có thể giải thích là vì redirection > được thực hiện bởi shell (do đó, nghĩa là thực hiện dưới quyền của 1 regular user – là user hiện tại chứ không phải dưới quyền của 1 super user hay cat. Do đó, không có quyền của super user, không thể truy cập đến /dev). Một solution em nghĩ tới và sử dụng trong khi thực hiện project này, đó là switch thành root user bằng command sudo su, sau đó chỉ việc cat/dev/<…> để đọc phần mong muốn. Với việc dùng sudo su, mọi command sẽ được thực hiện dưới quyền của 1 super user, kể cả shell, và việc này sẽ giải quyết được vấn đề nêu trên.
